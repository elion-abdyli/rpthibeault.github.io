<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Reflections on the Linux Kernel Mentorship &#8212; ~rpthibeault</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="~rpthibeault" href="../index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="reflections-on-the-linux-kernel-mentorship">
<h1>Reflections on the Linux Kernel Mentorship<a class="headerlink" href="#reflections-on-the-linux-kernel-mentorship" title="Link to this heading">¶</a></h1>
<p><strong>December 7, 2025</strong></p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>From September 2025 to December 2025, I was a mentee in the Linux Foundation’s <a class="reference external" href="https://wiki.linuxfoundation.org/lkmp">Linux Kernel Mentorship Program</a>.</p>
<p>The Linux Kernel Mentorship Program (LKMP) is an opportunity providing access to mentors while contributing to the Linux Kernel. At the end of the project term, mentees will have a much deeper knowledge of many subsystems of the Linux kernel and hopefully, many bugs fixed and many patches accepted.</p>
<p>I am looking to break into the kernel and operating system space to become a kernel software developer. I have wanted to contribute to Linux for a long time, and this was an excellent opportunity to get started and see what it is like.</p>
</section>
<section id="getting-started">
<h2>Getting started<a class="headerlink" href="#getting-started" title="Link to this heading">¶</a></h2>
<p>The objective of the LKMP is to contribute 5+ patches to the Linux Kernel. These patches may include fixes to compiler warnings, documentation, kselftest, drivers, and/or core kernel areas. However, mentees are encouraged to provide bug fixes rather than fixes to compiler warnings or documentation.</p>
<p>I chose to fix kernel bugs reported by <a class="reference external" href="https://syzkaller.appspot.com/upstream">Syzkaller</a>, the public dashboard for bugs found by the open-source <a class="reference external" href="https://github.com/google/syzkaller">syz fuzzer</a> provided by Google – this is very common for mentees and is encouraged by the program.</p>
<p>Syzkaller bugs are mostly kernel warnings, and reports from KASAN (Kernel Address Sanitizer), KMSAN (Memory), and UBSAN (Undefined Behavior). Note, Syzkaller bugs can be very challenging, especially for those new to the subsystem the bug is in. Not all reported bugs have reproducers, and even those that do may have very finicky environments and may not reproduce easily, if at all.</p>
<p>During the mentorship, I fixed 2 bugs in the Bluetooth subsystem, 1 bug in XFS, 1 bug in the loop driver,  and 1 bug in NTFS3. I will go over my workflow in the hopes that the reader finds it useful.</p>
<section id="testing">
<h3>Testing<a class="headerlink" href="#testing" title="Link to this heading">¶</a></h3>
<p>Before going into my workflow, I will mention that you should always know how to test your potential patch before you begin making changes. This isn’t anything complicated; know the subsystem’s testing tool. Often, the tester tools live outside of the main Linux repository. For instance, Bluetooth uses <a class="reference external" href="https://github.com/bluez/bluez">bluez</a>, and file systems (in general) use <a class="reference external" href="https://github.com/tytso/xfstests-bld">fstests</a>.</p>
<p>While kselftests are a good fallback option, do not rely on them for anything more than sanity checks.</p>
<p>Testing should not be an afterthought to fixing the bug. During the mentorship, I observed many of my peers having patches rejected for lack of testing and for introducing regressions.</p>
</section>
<section id="tools">
<h3>Tools<a class="headerlink" href="#tools" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://gitlab.com/qemu-project/qemu/-/tree/master">qemu</a></p></li>
<li><p><a class="reference external" href="https://sourceware.org/git/?p=binutils-gdb.git;a=summary">gdb</a></p></li>
<li><p><a class="reference external" href="https://github.com/google/syzkaller/tree/master">syzkaller</a></p></li>
</ul>
<p>I will not get into how to set up the tools or the developer environment; I leave that as an exercise to the reader.</p>
<p><strong>Note 1</strong>: I will mention I had to install qemu from their gitlab myself since the binary available by debian/ubuntu apt does not include much support for anything (e.g. qemu-xhci for Bluetooth/USB is not enabled). If you are having trouble with the tools, consider configuring and building them for yourself. And obviously, syzkaller was a local install as well; it’s useful for its bin executables to reproduce bugs using a syz reproducer if no C reproducer is available.</p>
<p><strong>Note 2</strong>: Be aware that KASAN bugs may be race conditions, so setting gdb breakpoints usually breaks the timing necessary for the bugs to happen.</p>
</section>
</section>
<section id="workflow">
<h2>Workflow<a class="headerlink" href="#workflow" title="Link to this heading">¶</a></h2>
<section id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h3>
<p>The generic overview of the workflow is as follows:</p>
<ol class="arabic simple">
<li><p>Attempt to reproduce a bug with either a C or syz reproducer on your local setup (using qemu or a test system)</p></li>
<li><p>Understand the code flow, debug,  and find a fix</p></li>
<li><p>Test the fix on your local setup</p></li>
<li><p>Write a commit log explaining what you are fixing (do not document the code, document the actual fix)</p></li>
<li><p>Send patch to relevant people and mailing lists</p></li>
<li><p>Repeat the process for <em>every</em> reply and new change to your patch</p></li>
</ol>
<p>Let’s go over one of the easier bugs I fixed during the program. It’s a classic KMSAN uninit-value. I will just go over Steps 1 and 2 of the workflow, and leave the rest as an exercise for the reader.</p>
<p>The bug: <a class="reference external" href="https://syzkaller.appspot.com/bug?extid=a9a4bedfca6aa9d7fa24">KMSAN: uninit-value in hci_cmd_complete_evt</a></p>
</section>
<section id="reproducing-the-bug">
<h3>Reproducing the bug<a class="headerlink" href="#reproducing-the-bug" title="Link to this heading">¶</a></h3>
<p>The first step to fixing a Syzkaller bug is to reproduce it. That way, you can test locally, instead of sending a patch test request email to Syzkaller for every fix you make, since those can take over an hour to complete.</p>
<p>The first step in reproducing the bug is to get the reproduction assets from Syzkaller. In our case:</p>
<div class="highlight-Bash notranslate"><div class="highlight"><pre><span></span>wget<span class="w"> </span>-O<span class="w"> </span>repro.c<span class="w"> </span>https://syzkaller.appspot.com/x/repro.c?163c6458580000
wget<span class="w"> </span>https://storage.googleapis.com/syzbot-assets/90b0fb888152/disk-9b0d551b.raw.xz
wget<span class="w"> </span>https://storage.googleapis.com/syzbot-assets/df9bbfa8cbe6/bzImage-9b0d551b.xz
</pre></div>
</div>
<p>unxz them:</p>
<div class="highlight-Bash notranslate"><div class="highlight"><pre><span></span>unxz<span class="w"> </span>bzImage-9b0d551b.xz<span class="w"> </span>disk-9b0d551b.raw.xz
</pre></div>
</div>
<p>Compile the C repro:</p>
<div class="highlight-Bash notranslate"><div class="highlight"><pre><span></span>gcc<span class="w"> </span>-o<span class="w"> </span>repro<span class="w"> </span>-lpthread<span class="w"> </span>-static<span class="w"> </span>repro.c
</pre></div>
</div>
<p>Now run qemu. My command was:</p>
<div class="highlight-Bash notranslate"><div class="highlight"><pre><span></span>qemu-system-x86_64<span class="w"> </span>-m<span class="w"> </span><span class="m">8192</span><span class="w"> </span>-smp<span class="w"> </span><span class="m">1</span><span class="w"> </span>-machine<span class="w"> </span>q35,accel<span class="o">=</span>kvm<span class="w"> </span>-cpu<span class="w"> </span>host<span class="w"> </span><span class="se">\</span>
-kernel<span class="w"> </span>bzImage-9b0d551b<span class="w"> </span><span class="se">\</span>
-append<span class="w"> </span><span class="s2">&quot;root=/dev/vda1 console=ttyS0&quot;</span><span class="w"> </span><span class="se">\</span>
-drive<span class="w"> </span><span class="nv">file</span><span class="o">=</span>disk-9b0d551b.raw,format<span class="o">=</span>raw,if<span class="o">=</span>virtio,id<span class="o">=</span>hd0<span class="w"> </span><span class="se">\</span>
-nographic<span class="w"> </span>-enable-kvm<span class="w"> </span><span class="se">\</span>
-netdev<span class="w"> </span>user,id<span class="o">=</span>net0,hostfwd<span class="o">=</span>tcp::10022-:22<span class="w"> </span><span class="se">\</span>
-device<span class="w"> </span>qemu-xhci,id<span class="o">=</span>xhci
</pre></div>
</div>
<p>Just 1 CPU is necessary for this bug.</p>
<p><strong>Note</strong>:
For debugging, you’ll want to add the flags <code class="docutils literal notranslate"><span class="pre">-s</span> <span class="pre">-S</span></code> which will hang the VM until you connect to it with gdb, e.g. <code class="docutils literal notranslate"><span class="pre">gdb</span> <span class="pre">-tui</span> <span class="pre">-ex</span> <span class="pre">'target</span> <span class="pre">remote</span> <span class="pre">localhost:1234'</span> <span class="pre">&lt;the-vmlinux-being-used&gt;</span></code></p>
<p><strong>Note</strong>: appending <code class="docutils literal notranslate"><span class="pre">2&gt;&amp;1</span> <span class="pre">|</span> <span class="pre">tee</span> <span class="pre">vm.log</span></code> to the end of the command is helpful; it will copy the vm output into a file called vm.log.</p>
<p><strong>Note</strong>: having a .gdbinit with the following is also helpful; these will copy the gdb output to a file called gdb.txt:</p>
<div class="highlight-Bash notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span><span class="w"> </span>trace-commands<span class="w"> </span>on
<span class="nb">set</span><span class="w"> </span>logging<span class="w"> </span>enabled
</pre></div>
</div>
<p>In another terminal, you’ll want to copy the repro into the vm:</p>
<div class="highlight-Bash notranslate"><div class="highlight"><pre><span></span>scp<span class="w"> </span>-O<span class="w"> </span>-P<span class="w"> </span><span class="m">10022</span><span class="w"> </span>-o<span class="w"> </span><span class="nv">UserKnownHostsFile</span><span class="o">=</span>/dev/null<span class="w"> </span>-o<span class="w"> </span><span class="nv">StrictHostKeyChecking</span><span class="o">=</span>no<span class="w"> </span>-o<span class="w"> </span><span class="nv">IdentitiesOnly</span><span class="o">=</span>yes<span class="w"> </span>repro<span class="w"> </span>root@127.0.0.1:/root/
</pre></div>
</div>
<p>Run the repro in the VM and wait a second for the VM to crash:</p>
<div class="highlight-Bash notranslate"><div class="highlight"><pre><span></span>./repro
</pre></div>
</div>
<p>If the repro doesn’t crash the VM, you’ve done something wrong.</p>
<p>Now that we can reproduce the bug, we can make changes with the belief that when testing locally, we can see if we have fixed it. Then send a patch test request email to Syzkaller later to verify.</p>
<p>If you want to test the kernel with a fix, you’ll want to get the .config from the reproduction assets:</p>
<div class="highlight-Bash notranslate"><div class="highlight"><pre><span></span>wget<span class="w"> </span>-O<span class="w"> </span>.config<span class="w"> </span>https://syzkaller.appspot.com/x/.config?x<span class="o">=</span>50fb29d81ff5a3df
</pre></div>
</div>
<p>Then build the kernel with your fix. KMSAN (and KASAN) is a LLVM tool, so you must use Clang and ld.lld. Use -j[number of CPUs] to accelerate the build:</p>
<div class="highlight-Bash notranslate"><div class="highlight"><pre><span></span>make<span class="w"> </span><span class="nv">CC</span><span class="o">=</span>clang<span class="w"> </span><span class="nv">LD</span><span class="o">=</span>ld.lld<span class="w"> </span>-j8
</pre></div>
</div>
</section>
<section id="fixing-the-bug">
<h3>Fixing the bug<a class="headerlink" href="#fixing-the-bug" title="Link to this heading">¶</a></h3>
<p>Let’s look at the stack trace of the crash:</p>
<div class="highlight-crash notranslate"><div class="highlight"><pre><span></span>BUG: KMSAN: uninit-value in hci_cmd_complete_evt+0xca3/0xe90 net/bluetooth/hci_event.c:4226
  hci_cmd_complete_evt+0xca3/0xe90 net/bluetooth/hci_event.c:4226
  hci_event_func net/bluetooth/hci_event.c:7556 [inline]
  hci_event_packet+0xcdf/0x1e40 net/bluetooth/hci_event.c:7613
  hci_rx_work+0x9a8/0x12b0 net/bluetooth/hci_core.c:4099
  process_one_work kernel/workqueue.c:3263 [inline]
  process_scheduled_works+0xb8e/0x1d80 kernel/workqueue.c:3346
  worker_thread+0xedf/0x1590 kernel/workqueue.c:3427
  kthread+0xd59/0xf00 kernel/kthread.c:463
  ret_from_fork+0x233/0x380 arch/x86/kernel/process.c:148
  ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:245
[...]
Uninit was created at:
  slab_post_alloc_hook mm/slub.c:4953 [inline]
  slab_alloc_node mm/slub.c:5245 [inline]
  kmem_cache_alloc_node_noprof+0x989/0x16b0 mm/slub.c:5297
  kmalloc_reserve+0x13c/0x4b0 net/core/skbuff.c:579
  __alloc_skb+0x347/0x7d0 net/core/skbuff.c:670
  alloc_skb include/linux/skbuff.h:1383 [inline]
  bt_skb_alloc include/net/bluetooth/bluetooth.h:510 [inline]
  vhci_get_user drivers/bluetooth/hci_vhci.c:496 [inline]
  vhci_write+0x125/0x960 drivers/bluetooth/hci_vhci.c:616
  new_sync_write fs/read_write.c:593 [inline]
  vfs_write+0xbe2/0x15d0 fs/read_write.c:686
  ksys_write fs/read_write.c:738 [inline]
  __do_sys_write fs/read_write.c:749 [inline]
  __se_sys_write fs/read_write.c:746 [inline]
  __x64_sys_write+0x1fb/0x4d0 fs/read_write.c:746
  x64_sys_call+0x3014/0x3e30 arch/x86/include/generated/asm/syscalls_64.h:2
  do_syscall_x64 arch/x86/entry/syscall_64.c:63 [inline]
  do_syscall_64+0xd9/0x210 arch/x86/entry/syscall_64.c:94
  entry_SYSCALL_64_after_hwframe+0x77/0x7f

CPU: 1 UID: 0 PID: 5079 Comm: kworker/u9:1 Not tainted syzkaller #0 PREEMPT(none) 
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/18/2025
Workqueue: hci0 hci_rx_work
=====================================================
</pre></div>
</div>
<p>Since this is a KMSAN bug, which are typically easy to fix, I’ll leave out most of the crash report so we can focus on the crash itself.
The crash event, which we know is an “uninit-value” from the crash log, is at net/bluetooth/hci_event.c:4226. We know that line 4226 must be using an uninitialized value.</p>
<p>This is line 4226 in the commit syzkaller is testing:</p>
<blockquote>
<div><p><a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/bluetooth/hci_event.c?id=9b0d551bcc05fa4786689544a2845024db1d41b6#n4226">net/bluetooth/hci_event.c:4226</a></p>
</div></blockquote>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">hci_req_cmd_complete</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">opcode</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">status</span><span class="p">,</span><span class="w"> </span><span class="n">req_complete</span><span class="p">,</span>
<span class="w">                 </span><span class="n">req_complete_skb</span><span class="p">);</span>
</pre></div>
</div>
<p>What’s gone wrong here? Well, since the error is with this line in particular and there is no mention of the req_complete callback (which is hard-coded and assuredly a value), we can safely assume the uninit value is one of <code class="docutils literal notranslate"><span class="pre">hdev</span></code>, <code class="docutils literal notranslate"><span class="pre">*opcode</span></code>, or <code class="docutils literal notranslate"><span class="pre">*status</span></code>. Immediately, we rule out hdev since we would have crashed early if hdev were junk. So, we are crashing on a pointer dereference for either the opcode or the status.</p>
<p>The questions now: what is opcode, and what is status?</p>
<p>Let’s look at the entire function in its relevant entirety:</p>
<blockquote>
<div><p><a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/bluetooth/hci_event.c?id=9b0d551bcc05fa4786689544a2845024db1d41b6#n4194">net/bluetooth/hci_event.c:4194</a></p>
</div></blockquote>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">hci_cmd_complete_evt</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">hci_dev</span><span class="w"> </span><span class="o">*</span><span class="n">hdev</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">,</span>
<span class="w">                                </span><span class="k">struct</span><span class="w"> </span><span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="n">u16</span><span class="w"> </span><span class="o">*</span><span class="n">opcode</span><span class="p">,</span><span class="w"> </span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="n">status</span><span class="p">,</span>
<span class="w">                                </span><span class="n">hci_req_complete_t</span><span class="w"> </span><span class="o">*</span><span class="n">req_complete</span><span class="p">,</span>
<span class="w">                                </span><span class="n">hci_req_complete_skb_t</span><span class="w"> </span><span class="o">*</span><span class="n">req_complete_skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">hci_ev_cmd_complete</span><span class="w"> </span><span class="o">*</span><span class="n">ev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">    </span><span class="o">*</span><span class="n">opcode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__le16_to_cpu</span><span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">);</span>

<span class="w">    </span><span class="n">bt_dev_dbg</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;opcode 0x%4.4x&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">opcode</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">hci_cc_table</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hci_cc_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">op</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">opcode</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="o">*</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hci_cc_func</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hci_cc_table</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">skb</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">hci_cc_table</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Unknown opcode, assume byte 0 contains the status, so</span>
<span class="cm">         * that e.g. __hci_cmd_sync() properly returns errors</span>
<span class="cm">         * for vendor specific commands send by HCI drivers.</span>
<span class="cm">         * If a vendor doesn&#39;t actually follow this convention we may</span>
<span class="cm">         * need to introduce a vendor CC table in order to properly set</span>
<span class="cm">         * the status.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="o">*</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">handle_cmd_cnt_and_timer</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span><span class="w"> </span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">ncmd</span><span class="p">);</span>

<span class="w">    </span><span class="n">hci_req_cmd_complete</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">opcode</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">status</span><span class="p">,</span><span class="w"> </span><span class="n">req_complete</span><span class="p">,</span>
<span class="w">                     </span><span class="n">req_complete_skb</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* ... snip ... */</span>
</pre></div>
</div>
<p>We have the opcode set as the event opcode, and then immediately use it with the debug print:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="o">*</span><span class="n">opcode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__le16_to_cpu</span><span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">);</span>

<span class="w">    </span><span class="n">bt_dev_dbg</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;opcode 0x%4.4x&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">opcode</span><span class="p">);</span>
</pre></div>
</div>
<p>This means we can rule it out. The uninit error would have occurred at the debug statement if the opcode was uninitialized memory.</p>
<p>We move on to status, which is set by:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">hci_cc_table</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Unknown opcode, assume byte 0 contains the status, so</span>
<span class="cm">         * that e.g. __hci_cmd_sync() properly returns errors</span>
<span class="cm">         * for vendor specific commands send by HCI drivers.</span>
<span class="cm">         * If a vendor doesn&#39;t actually follow this convention we may</span>
<span class="cm">         * need to introduce a vendor CC table in order to properly set</span>
<span class="cm">         * the status.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="o">*</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
<p>Aha, so the status is set to the first byte of the socket buffer’s data. And per the comment, this is due to an unknown opcode; we assume that byte 0 contains the status so that the sync command function can properly return errors for vendor-specific commands sent by HCI drivers. In other words, we support vendor-specific commands sent by HCI drivers; therefore, we can’t just throw away packets with unknown opcodes - they might be custom commands.</p>
<p>We can verify that the comment is telling the truth about the unknown opcode, since earlier in the function loop variable <code class="docutils literal notranslate"><span class="pre">i</span></code> would be less than hci_cc_table size if the opcode were in the hci_cc_table:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">hci_cc_table</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hci_cc_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">op</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">opcode</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="o">*</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hci_cc_func</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hci_cc_table</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">skb</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
<p>So we hypothesize that <code class="docutils literal notranslate"><span class="pre">skb-&gt;data[0]</span></code> is uninitialized memory. But why is it uninitialized?</p>
<p>We can look at Syzkaller’s repro.c to see what’s happening that led to this point. Looking at the crash stack trace from earlier, we know that <code class="docutils literal notranslate"><span class="pre">Uninit</span> <span class="pre">was</span> <span class="pre">created</span> <span class="pre">at:</span></code> began with a write syscall. This is what the repro.c is doing:</p>
<blockquote>
<div><p><a class="reference external" href="https://syzkaller.appspot.com/text?tag=ReproC&amp;amp;x=163c6458580000">repro.c</a></p>
</div></blockquote>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">syz_emit_vhci</span><span class="p">(</span><span class="k">volatile</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">a1</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vhci_fd</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">a0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a1</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">write</span><span class="p">(</span><span class="n">vhci_fd</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">execute_one</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* snip */</span>
<span class="w">    </span><span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mh">0x200000000080</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\x04\x0e</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">syz_emit_vhci</span><span class="p">(</span><span class="cm">/*data=*/</span><span class="mh">0x200000000080</span><span class="p">,</span><span class="w"> </span><span class="cm">/*size=*/</span><span class="mi">6</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We observe that we’re memcpy-ing whatever “\x04\x0e” is, which is of size 2, to 0x200000000080. Then, with a write syscall, we’re writing 6 bytes of our data (at 0x200000000080) to a vhci file descriptor. In other words, we’re writing a packet to vhci so it can be sent over Bluetooth.</p>
<p>But hold on, we’re memcpy-ing 2 bytes but writing 6? That’s curious. Are the remaining 4 bytes from junk where the uninit memory is coming from? That <em>surely</em> is the case since we’re writing a packet containing [0x04 0x0e junk1 junk2 junk3 junk4] to vhci, right? No. The kernel doesn’t care about userspace junk. For the kernel, userspace sends it a request, and junk1-junk4 are just potential values that the kernel must check. The KMSAN is on the kernel side, not because of the userspace input.</p>
<p>Hence, we must investigate further. What are we actually sending here? How does our input lead to the scenario that results in the KMSAN uninit value?</p>
<p>Well, from hci_cmd_complete_evt(), we know we’re in a Command Complete Event, so let’s see what that “\x04\x0e” means.</p>
<p>Let’s look up “Host Controller interface (HCI)” in the Bluetooth documentation. I’ll spare the reader the pain of finding what we’re looking for in the Bluetooth docs.
The HCI docs are <a class="reference external" href="https://www.bluetooth.com/wp-content/uploads/Files/Specification/HTML/Core-54/out/en/host-controller-interface/host-controller-interface-functional-specification.html">here</a>.
From reading the docs, the first value of the header is the <a class="reference external" href="https://www.bluetooth.com/wp-content/uploads/Files/Specification/HTML/Core-54/out/en/host-controller-interface/three-wire-uart-transport-layer.html#UUID-1cf959bb-57a0-e782-4324-a9bc4ee3f134">Packet Type</a>. The value 0x04 means the packet is an <a class="reference external" href="https://www.bluetooth.com/wp-content/uploads/Files/Specification/HTML/Core-54/out/en/host-controller-interface/host-controller-interface-functional-specification.html#UUID-f209cdf7-0496-8bcd-b7e1-500831511378">HCI Event Packet</a>. From here, we know that an event packet is of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Event</span> <span class="n">Packet</span> <span class="n">Format</span><span class="p">:</span>
<span class="o">-</span> <span class="n">Event</span> <span class="n">Code</span> <span class="p">(</span><span class="mi">1</span> <span class="n">byte</span><span class="p">)</span>
<span class="o">-</span> <span class="n">Parameter</span> <span class="n">Total</span> <span class="n">Length</span> <span class="p">(</span><span class="mi">1</span> <span class="n">byte</span><span class="p">)</span>
<span class="o">-</span> <span class="n">Event</span> <span class="n">Parameters</span> <span class="p">(</span><span class="n">variable</span><span class="p">)</span>
</pre></div>
</div>
<p>Therefore,  0x0E is the event code, which indeed is <a class="reference external" href="https://www.bluetooth.com/wp-content/uploads/Files/Specification/HTML/Core-54/out/en/host-controller-interface/host-controller-interface-functional-specification.html#UUID-76d31a33-1a9e-07bc-87c4-8ebffee065fd">HCI Command Complete Event</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Command</span> <span class="n">Complete</span> <span class="n">Event</span> <span class="n">Format</span><span class="p">:</span>
<span class="o">-</span> <span class="n">Num_HCI_Command_Packets</span> <span class="p">(</span><span class="mi">1</span> <span class="n">byte</span><span class="p">)</span>
<span class="o">-</span> <span class="n">Command_Opcode</span> <span class="p">(</span><span class="mi">2</span> <span class="nb">bytes</span><span class="p">)</span>
<span class="o">-</span> <span class="n">Return</span> <span class="n">Parameters</span> <span class="p">(</span><span class="n">variable</span><span class="p">)</span>
</pre></div>
</div>
<p>So we observe that skb-&gt;data is supposed to contain the event parameters <code class="docutils literal notranslate"><span class="pre">Num_HCI_Command_Packets</span></code>, <code class="docutils literal notranslate"><span class="pre">Command_Opcode</span></code>, and <code class="docutils literal notranslate"><span class="pre">Return</span> <span class="pre">Parameters</span></code>, all of which are junk values. However, recall the code above, in the case of an unknown opcode, skb-&gt;data[0] is supposed to be the status. Where have all the other values in the data gone, then?</p>
<p>Let’s go up the stack trace into hci_event_func() and hci_event_packet().</p>
<p><strong>Note</strong>: Since hci_event_packet() is a long function I’ll link it <a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/bluetooth/hci_event.c?id=9b0d551bcc05fa4786689544a2845024db1d41b6#n7562">here</a> and summarize that event code and parameter total length are part of the header, and have both been pulled. Hence, only the event parameters remain in <code class="docutils literal notranslate"><span class="pre">skb-&gt;data</span></code> when we reach <code class="docutils literal notranslate"><span class="pre">hci_event_func()</span></code>.</p>
<blockquote>
<div><p><a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/bluetooth/hci_event.c?id=9b0d551bcc05fa4786689544a2845024db1d41b6#n7525">net/bluetooth/hci_event.c:7525</a></p>
</div></blockquote>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">hci_event_func</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">hci_dev</span><span class="w"> </span><span class="o">*</span><span class="n">hdev</span><span class="p">,</span><span class="w"> </span><span class="n">u8</span><span class="w"> </span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sk_buff</span><span class="w"> </span><span class="o">*</span><span class="n">skb</span><span class="p">,</span>
<span class="w">                           </span><span class="n">u16</span><span class="w"> </span><span class="o">*</span><span class="n">opcode</span><span class="p">,</span><span class="w"> </span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="n">status</span><span class="p">,</span>
<span class="w">                           </span><span class="n">hci_req_complete_t</span><span class="w"> </span><span class="o">*</span><span class="n">req_complete</span><span class="p">,</span>
<span class="w">                           </span><span class="n">hci_req_complete_skb_t</span><span class="w"> </span><span class="o">*</span><span class="n">req_complete_skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">hci_ev</span><span class="w"> </span><span class="o">*</span><span class="n">ev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hci_ev_table</span><span class="p">[</span><span class="n">event</span><span class="p">];</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">min_len</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">bt_dev_err</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;unexpected event 0x%2.2x length: %u &lt; %u&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">min_len</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* Just warn if the length is over max_len size it still be</span>
<span class="cm">     * possible to partially parse the event so leave to callback to</span>
<span class="cm">     * decide if that is acceptable.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">max_len</span><span class="p">)</span>
<span class="w">        </span><span class="n">bt_dev_warn_ratelimited</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span>
<span class="w">                                </span><span class="s">&quot;unexpected event 0x%2.2x length: %u &gt; %u&quot;</span><span class="p">,</span>
<span class="w">                                </span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">max_len</span><span class="p">);</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hci_ev_skb_pull</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span><span class="w"> </span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">min_len</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">)</span>
<span class="w">        </span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">func_req</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">skb</span><span class="p">,</span><span class="w"> </span><span class="n">opcode</span><span class="p">,</span><span class="w"> </span><span class="n">status</span><span class="p">,</span><span class="w"> </span><span class="n">req_complete</span><span class="p">,</span>
<span class="w">                     </span><span class="n">req_complete_skb</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since all the checks pass in hci_event_packet() and hci_event_func() and we get to the req_complete callback, which is hci_cmd_complete_evt(), we know 2 things:</p>
<ol class="arabic simple">
<li><p>The packet is correct structurally.</p></li>
<li><p>The event parameters have all been pulled by <code class="docutils literal notranslate"><span class="pre">hci_ev_skb_pull()</span></code>, and therefore the skb-&gt;data is empty, and skb-&gt;len is 0.
This is confirmed by debugging with gdb, which is left as an exercise to the reader.</p></li>
</ol>
<p>So, to answer our original questions from before,</p>
<div class="highlight-txt notranslate"><div class="highlight"><pre><span></span>Hence, we must investigate further. What are we actually sending here? How does our input lead to the scenario that results in the KMSAN uninit value?
</pre></div>
</div>
<p>What we are actually sending here is:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">byte</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">packet</span><span class="w"> </span><span class="n">type</span><span class="o">:</span><span class="w"> </span><span class="mh">0x04</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">HCI</span><span class="w"> </span><span class="n">Event</span><span class="w"> </span><span class="n">Packet</span>
<span class="n">byte</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Event_Code</span><span class="o">:</span><span class="w"> </span><span class="mh">0x0e</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">HCI</span><span class="w"> </span><span class="n">Command</span><span class="w"> </span><span class="n">Complete</span><span class="w"> </span><span class="n">Event</span>
<span class="n">byte</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Num_HCI_Command_Packets</span><span class="o">:</span><span class="w"> </span><span class="n">junk</span><span class="w"> </span><span class="mi">1</span>
<span class="n">byte</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Command_Opcode</span><span class="o">:</span><span class="w"> </span><span class="n">junk</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="n">Note</span><span class="o">:</span><span class="w"> </span><span class="n">Command_Opcode</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="n">large</span><span class="p">)</span>
<span class="n">byte</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Command_Opcode</span><span class="o">:</span><span class="w"> </span><span class="n">junk</span><span class="w"> </span><span class="mi">3</span>
<span class="n">byte</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Return_Parameters</span><span class="o">:</span><span class="w"> </span><span class="n">junk</span><span class="w"> </span><span class="mi">4</span>
</pre></div>
</div>
<p>And what actually matters is that the opcode is some junk value that’s not recognized. Curiously, this coincides with the specific scenario we discussed earlier: if an opcode is unknown, byte 0 contains the status. This is done to support vendor-specific commands sent by HCI drivers.</p>
<p>Now we look back at our hypothesis:</p>
<div class="highlight-txt notranslate"><div class="highlight"><pre><span></span>So we hypothesize that `skb-&gt;data[0]` is uninitialized memory. But why is it uninitialized? 
</pre></div>
</div>
<p>The answer: we know that skb-&gt;data[0] is uninitialized memory because all the data was pulled in hci_event_func(), leaving skb-&gt;data empty. Hence, the crash is actually an array-out-of-bounds bug reported as an uninitialized memory bug (by coincidence, skb-&gt;data[0] now so happens to point to uninitialized memory).</p>
<p>The crash is clear: skb-&gt;data[0] is out of bounds since skb-&gt;data is empty, and skb-&gt;len is 0.</p>
<p>Hence, the fix in this case is just adding a check for skb length for an unknown Command Complete Event Command_Opcode:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">hci_cc_table</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="o">+</span><span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="o">+</span><span class="w">           </span><span class="n">bt_dev_err</span><span class="p">(</span><span class="n">hdev</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;unexpected cc 0x%4.4x with no status&quot;</span><span class="p">,</span>
<span class="o">+</span><span class="w">                           </span><span class="o">*</span><span class="n">opcode</span><span class="p">);</span>
<span class="o">+</span><span class="w">           </span><span class="o">*</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HCI_ERROR_UNSPECIFIED</span><span class="p">;</span>
<span class="o">+</span><span class="w">           </span><span class="k">return</span><span class="p">;</span>
<span class="o">+</span><span class="w">       </span><span class="p">}</span>
<span class="o">+</span>
<span class="w">        </span><span class="cm">/* Unknown opcode, assume byte 0 contains the status, so</span>
<span class="cm">         * that e.g. __hci_cmd_sync() properly returns errors</span>
<span class="cm">         * for vendor specific commands send by HCI drivers.</span>
<span class="cm">         * If a vendor doesn&#39;t actually follow this convention we may</span>
<span class="cm">         * need to introduce a vendor CC table in order to properly set</span>
<span class="cm">         * the status.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="o">*</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* snip */</span>
</pre></div>
</div>
<p>Not all bugs are this simple to fix. The other bugs I fixed were too complex to explain concisely in a blog such as this.</p>
<p>Also,  the first patch is usually incorrect. Either it will be incomplete because you didn’t take certain things into account due to unfamiliarity with the subsystem, or it was simply wrong. Regardless, if the patch is useful, it will provoke discussion that proposing fixes. In this case, my first patch for this bug was to reject packets with a junk Num_HCI_Command_Packets value, which proved to be too big a hammer for a junk value.</p>
</section>
</section>
<section id="reflections">
<h2>Reflections<a class="headerlink" href="#reflections" title="Link to this heading">¶</a></h2>
<p>I spent my time in the Linux Kernel Mentorship Program fixing Syzkaller bugs.</p>
<p>I deliberately avoided the low-hanging fruit, easy fixes for compiler warnings and Documentation changes, because I find them uninteresting, and also because I observed many of my peers’ patches being seen as pointless and rejected by maintainers. You have to empathize with the maintainers here; they receive dozens of patches to their subsystem per day, and adding more to their workload to fix compiler warnings is a waste of their time. Therefore, you should only work on compiler warnings and so on as a last resort if you are unable to understand syzbot bugs – and even then, only until you get a better understanding of the development process. This isn’t a program for complete beginners; you should be able to fix some bugs.</p>
<p>However, the direction I took in the program does have a steep learning curve due to the different subsystems. For every subsystem, you must learn how it works and how the maintainer(s) like to do things. How do they test? Do they like patches submitted in a specific way? Moreover, you’re not just learning a ‘subsystem’, you’re learning a technology. For example, with Bluetooth, you must know how Bluetooth works in general, and how the the driver works, in addition to figuring out how to fix a bug. The learning curve is why I advise most people to stick to 1-2 subsystems rather than the 4 I did. But if you are willing to spend lots of time learning subsystems, then fixing bugs in several of them is absolutely worth it. I now know how Bluetooth, xfs, ntfs3, and loop/block work to a degree that I can send a cogent patch to them all without further investigation.</p>
<p>In sum, the LKMP was challenging and having mentors there to guide me through sending my first patch proved valuable. I am grateful for my experience in the Linux Kernel Mentorship Program and thank Shuah Khan, David Hunter, and Khalid Aziz for being great mentors and resources to learn from.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">~rpthibeault</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Reflections on the Linux Kernel Mentorship</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#getting-started">Getting started</a></li>
<li class="toctree-l2"><a class="reference internal" href="#workflow">Workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reflections">Reflections</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="../index.html" title="previous chapter">~rpthibeault</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Raphaël Pinsonneault-Thibeault.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/posts/linux-kernel-mentorship.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>